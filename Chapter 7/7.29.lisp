(setf database '((b1 shape brick)
                 (b1 color green)
                 (b1 size small)
                 (b1 supported-by b2)
                 (b1 supported-by b3)
                 (b2 shape brick)
                 (b2 color red)
                 (b2 size small)
                 (b2 supports b1)
                 (b2 left-of b3)
                 (b3 shape brick)
                 (b3 color red)
                 (b3 size small)
                 (b3 supports b1)
                 (b3 right-of b2)
                 (b4 shape pyramid)
                 (b4 color blue)
                 (b4 size large)
                 (b4 supported-by b5)
                 (b5 shape cube)
                 (b5 color green)
                 (b5 size large)
                 (b5 supports b4)
                 (b6 shape brick)
                 (b6 color purple)
                 (b6 size large)))

(defun match-element (element to)
  (and
    (not (equal element '?))
    (or
      (equal to '?)
      (equal element to))))

(defun match-triple (assertion pattern)
  (and (match-element (first assertion) (first pattern))
       (match-element (second assertion) (second pattern))
       (match-element (third assertion) (third pattern))))

(defun fetch (pattern)
  (remove-if-not
    #'(lambda (assertion) (match-triple assertion pattern))
    database))

(defun ask-color (block-name)
  (list block-name 'color '?))

(defun supporters (block-name)
  (let* ((pattern (list block-name 'supported-by '?))
         (answer (fetch pattern)))
    (mapcar #'third answer)))

(defun supp-cube (block-name)
  (let* ((rests-on (supporters block-name))
         (shapes-below (mapcar
                         #'(lambda (block-name) (third (car (fetch (list block-name 'shape '?)))))
                         rests-on)))
    (find-if
      #'(lambda (shape-below) (equal shape-below 'cube))
      shapes-below)))

(defun desc1 (block-name)
  (fetch (list block-name '? '?)))

(defun desc2 (block-name)
  (mapcar #'rest (desc1 block-name)))

(defun description (block-name)
  (reduce #'append (desc2 block-name)))

(let ((parta1 '(match-element 'red 'red))
      (parta2 '(match-element 'red '?))
      (parta3 '(match-element 'red 'blue))
      (partb1 '(match-triple '(b2 color red) '(b2 color ?)))
      (partb2 '(match-triple '(b2 color red) '(b2 color green)))
      (partc1 '(fetch '(b2 color ?)))
      (partc2 '(fetch '(? supports b1)))
      (partd1 '(mapcar #'third (fetch '(b4 shape ?))))
      (partd2 '(mapcar #'first (fetch '(? shape brick))))
      (partd3 '(fetch '(b2 ? b3)))
      (partd4 '(fetch '(? color ?)))
      (partd5 '(fetch '(b4 ? ?)))
      (parte1 '(ask-color 'b3))
      (partf1 '(supporters 'b1))
      (partg1 '(supp-cube 'b4))
      (partg2 '(supp-cube 'b1))
      (parth1 '(desc1 'b6))
      (parti1 '(desc2 'b6))
      (partj1 '(description 'b6))
      (partk1 '(description 'b1))
      (partk2 '(description 'b4))
      (partl1 '(append '((b1 made-of wood) (b2 made-of plastic)) database)))
  (format t "~s = ~s~%" parta1 (eval parta1))
  (format t "~s = ~s~%" parta2 (eval parta2))
  (format t "~s = ~s~%" parta3 (eval parta3))
  (format t "~s = ~s~%" partb1 (eval partb1))
  (format t "~s = ~s~%" partb2 (eval partb2))
  (format t "~s = ~s~%" partc1 (eval partc1))
  (format t "~s = ~s~%" partc2 (eval partc2))
  (format t "~s = ~s~%" partd1 (eval partd1))
  (format t "~s = ~s~%" partd2 (eval partd2))
  (format t "~s = ~s~%" partd3 (eval partd3))
  (format t "~s = ~s~%" partd4 (eval partd4))
  (format t "~s = ~s~%" partd5 (eval partd5))
  (format t "~s = ~s~%" parte1 (eval parte1))
  (format t "~s = ~s~%" partf1 (eval partf1))
  (format t "~s = ~s~%" partg1 (eval partg1))
  (format t "~s = ~s~%" partg2 (eval partg2))
  (format t "~s = ~s~%" parth1 (eval parth1))
  (format t "~s = ~s~%" parti1 (eval parti1))
  (format t "~s = ~s~%" partj1 (eval partj1))
  (format t "~s = ~s~%" partk1 (eval partk1))
  (format t "~s = ~s~%" partk2 (eval partk2))
  (format t "~s = ~s~%" partl1 (eval partl1)))
