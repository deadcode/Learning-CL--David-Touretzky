(defun complement-base (inp-base)
  (do* ((bases '(A G T C))
        (complements '(T C A G))
        (b bases (rest b))
        (c complements (rest c))
        (b1 (first b) (first b))
        (c1 (first c) (first c)))
    ((null b) nil)
    (when (equal b1 inp-base)
      (return-from complement-base c1))))

(defun complement-strand (strand)
  (do* ((c nil (push c1 c))
        (s strand (rest s))
        (s1 (first s) (first s))
        (c1 (complement-base s1) (complement-base s1)))
    ((null s) (nreverse c))))

(defun make-double (strand)
  (do* ((d nil (push d1 d))
        (s strand (rest s))
        (c (complement-strand strand) (rest c))
        (s1 (first s) (first s))
        (c1 (first c) (first c))
        (d1 (list s1 c1) (list s1 c1)))
    ((or (null s) (null c)) (nreverse d))))

(defun count-bases (strand)
  (labels ((update-table (base table)
                         ;(format t "~&Updating ~s in ~s" base table)
                         (incf (second (assoc base table)))))
    ;(let ((base-counts '((a 0)(t 0)(g 0)(c 0))))
    (let ((base-counts (list (list 'a 0)(list 'c 0)(list 'g 0)(list 't 0))))
      (dolist (e strand base-counts)
        (cond ((atom e) (update-table e base-counts))
              (t (update-table (first e) base-counts)
                 (update-table (second e) base-counts)))))))

(defun prefixp (strand1 strand2)
  (do ((s1 strand1 (rest s1))
       (s2 strand2 (rest s2)))
    ((null s1) s2)
    (when (or (null s2)
              (not (equal (first s1) (first s2))))
      (return-from prefixp nil))))

(defun appearsp (strand1 strand2)
  (do ((s2 strand2 (rest s2)))
    ((null s2) nil)
    (when (prefixp strand1 s2)
      (return-from appearsp t))))

(defun coverp (strand1 strand2)
  (do ((s1 strand1)
       (s2 strand2))
    ((and (null s1) (null s2)) t)
    (cond ((null s1)
           (setf s1 strand1))
          ((equal (first s1) (first s2))
           (setf s1 (rest s1))
           (setf s2 (rest s2)))
          (t (return-from coverp nil)))))

(defun prefix (n strand)
  (do ((p nil (push (first s) p))
       (s strand (rest s))
       (cnt n (decf cnt)))
    ((zerop cnt) (reverse p))))

(defun kernel (strand)
  (do* ((cnt 1 (incf cnt))
        (k (prefix cnt strand) (prefix cnt strand)))
    ((coverp k strand) k)))

(defun draw-dna (strand)
  (let ((n (length strand)))
    (draw-string n "---")
    (draw-string n " ! ")
    (draw-bases strand)
    (draw-string n " . ")
    (draw-string n " . ")
    (draw-bases (complement-strand strand))
    (draw-string n " ! ")
    (draw-string n "---")))

(defun draw-string (cnt string)
  (format t "~&")
  (dotimes (i cnt)
    (format t "~A" string)))

(defun draw-bases (strand)
  (format t "~&")
  (dolist (base strand)
    (format t " ~A " base)))

(let ((testa1 '(complement-base 'a))
      (testa2 '(complement-base 'g))
      (testa3 '(complement-base 't))
      (testa4 '(complement-base 'c))
      (testa5 '(complement-base 'f))
      (testb1 '(complement-strand '(a g g t)))
      (testb2 '(complement-strand '(a g c t)))
      (testb3 '(complement-strand '()))
      (testc1 '(make-double '(g g a c t)))
      (testd1 '(count-bases '((g c)(a t)(t a)(t a)(c g))))
      (testd2 '(count-bases '(a g t a c t c t)))
      (testd3 '(count-bases (complement-strand '(a g t a c t c t))))
      (teste1 '(prefixp '(g t c) '(g t c a t)))
      (teste2 '(prefixp '(g t c a t) '(g t c)))
      (teste3 '(prefixp '(g t c) '(a g g t c)))
      (testf1 '(appearsp '(c a t) '(t c a t g)))
      (testf2 '(appearsp '(c a t) '(t c c g t a)))
      (testf3 '(appearsp '(t c a t g) '(c a t)))
      (testf4 '(appearsp '(c a t) '()))
      (testf5 '(appearsp '() '(c a t)))
      (testg1 '(coverp '(a g c) '(a g c a g c a g c)))
      (testg2 '(coverp '(a g c) '(a g c t t g)))
      (testh1 '(prefix 4 '(c g a t t a g)))
      (testh2 '(prefix 5 '(c g a)))
      (testi1 '(kernel '(a g c a g c a g c)))
      (testi2 '(kernel '(a a a a a)))
      (testi3 '(kernel '(a g g t c)))
      (testj1 '(draw-dna '(a g g t c a t t g))))
  (format t "~&~s = ~s" testa1 (eval testa1))
  (format t "~&~s = ~s" testa2 (eval testa2))
  (format t "~&~s = ~s" testa3 (eval testa3))
  (format t "~&~s = ~s" testa4 (eval testa4))
  (format t "~&~s = ~s" testa5 (eval testa5))
  (format t "~&~s = ~s" testb1 (eval testb1))
  (format t "~&~s = ~s" testb2 (eval testb2))
  (format t "~&~s = ~s" testb3 (eval testb3))
  (format t "~&~s = ~s" testc1 (eval testc1))
  (format t "~&~s = ~s" testd1 (eval testd1))
  (format t "~&~s = ~s" testd2 (eval testd2))
  (format t "~&~s = ~s" testd3 (eval testd3))
  (format t "~&~s = ~s" teste1 (eval teste1))
  (format t "~&~s = ~s" teste2 (eval teste2))
  (format t "~&~s = ~s" teste3 (eval teste3))
  (format t "~&~s = ~s" testf1 (eval testf1))
  (format t "~&~s = ~s" testf2 (eval testf2))
  (format t "~&~s = ~s" testf3 (eval testf3))
  (format t "~&~s = ~s" testf4 (eval testf4))
  (format t "~&~s = ~s" testf5 (eval testf5))
  (format t "~&~s = ~s" testg1 (eval testg1))
  (format t "~&~s = ~s" testg2 (eval testg2))
  (format t "~&~s = ~s" testh1 (eval testh1))
  (format t "~&~s = ~s" testh2 (eval testh2))
  (format t "~&~s = ~s" testi1 (eval testi1))
  (format t "~&~s = ~s" testi2 (eval testi2))
  (format t "~&~s = ~s" testi3 (eval testi3))
  (format t "~&Testing ~s" testj1)
  (eval testj1))
